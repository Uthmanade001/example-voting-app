name: Deploy to k3s on EC2 (via SSM)

on:
  push:
    branches: [ "main" ]
  workflow_dispatch:
    inputs:
      image_tag:
        description: "Image tag to deploy (defaults to the commit SHA)"
        required: false
        default: ""

env:
  AWS_REGION: eu-west-2
  IMAGE_TAG: ${{ github.event.inputs.image_tag != '' && github.event.inputs.image_tag || github.sha }}

jobs:
  deploy:
    runs-on: ubuntu-latest

    env:
      ECR_REGISTRY: ${{ secrets.ECR_REGISTRY }}          # e.g. 389890955868.dkr.ecr.eu-west-2.amazonaws.com
      EC2_INSTANCE_ID: ${{ secrets.EC2_INSTANCE_ID }}
      POSTGRES_USER: ${{ secrets.POSTGRES_USER }}
      POSTGRES_PASSWORD: ${{ secrets.POSTGRES_PASSWORD }}
      POSTGRES_DB: ${{ secrets.POSTGRES_DB }}

    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Get ECR password on runner (base64-encode)
        id: ecrpw
        shell: bash
        run: |
          set -euo pipefail
          PW="$(aws ecr get-login-password --region "${AWS_REGION}")"
          PW_B64="$(printf %s "$PW" | base64 -w0)"
          echo "pw_b64=${PW_B64}" >> "$GITHUB_OUTPUT"

      - name: Send SSM command (install k3s + deploy)
        id: ssm
        shell: bash
        run: |
          set -euo pipefail

          read -r -d '' USER_SCRIPT <<'EOS'
          set -euo pipefail
          set -x

          AWS_REGION="__AWS_REGION__"
          ECR="__ECR__"
          TAG="__TAG__"
          PUSER="__PUSER__"
          PPASS="__PPASS__"
          PDB="__PDB__"
          ECR_PW_B64="__ECR_PW_B64__"

          # 1) Install k3s if missing (make kubeconfig readable)
          if ! command -v k3s >/dev/null 2>&1; then
            curl -sfL https://get.k3s.io | env K3S_KUBECONFIG_MODE=644 sh -
          fi

          # Ensure curl exists
          if ! command -v curl >/dev/null 2>&1; then
            if command -v yum >/dev/null 2>&1; then
              yum install -y curl
            else
              apt-get update -y && apt-get install -y curl
            fi
          fi

          export KUBECONFIG=/etc/rancher/k3s/k3s.yaml

          # 2) Download repo at the exact commit/tag
          WORKDIR=/opt/k8s
          rm -rf "$WORKDIR"
          mkdir -p "$WORKDIR"
          curl -L "https://github.com/Uthmanade001/example-voting-app/archive/${TAG}.tar.gz" -o /tmp/repo.tgz
          tar xzf /tmp/repo.tgz -C "$WORKDIR" --strip-components=1

          # 3) Replace placeholders
          sed -i "s|__ECR__|$ECR|g; s|__TAG__|$TAG|g" "$WORKDIR"/k8s/*.yaml

          # 4) Namespace & secrets
          k3s kubectl apply -f "$WORKDIR/k8s/namespace.yaml"

          k3s kubectl -n voting create secret generic db \
            --from-literal=POSTGRES_USER="$PUSER" \
            --from-literal=POSTGRES_PASSWORD="$PPASS" \
            --from-literal=POSTGRES_DB="$PDB" \
            --dry-run=client -o yaml | k3s kubectl apply -f -

          # ECR imagePull secret (password supplied by runner; decode safely)
          REG_SERVER="${ECR#https://}"
          ECR_PW="$(echo "$ECR_PW_B64" | base64 -d)"
          k3s kubectl -n voting create secret docker-registry ecr-creds \
            --docker-server="$REG_SERVER" \
            --docker-username=AWS \
            --docker-password="$ECR_PW" \
            --dry-run=client -o yaml | k3s kubectl apply -f -

          # 5) Apply workloads (NO wildcards)
          k3s kubectl -n voting apply -f "$WORKDIR/k8s/postgres.yaml"
          k3s kubectl -n voting apply -f "$WORKDIR/k8s/redis.yaml"
          k3s kubectl -n voting apply -f "$WORKDIR/k8s/vote.yaml"
          k3s kubectl -n voting apply -f "$WORKDIR/k8s/result.yaml"
          k3s kubectl -n voting apply -f "$WORKDIR/k8s/worker.yaml"

          # 6) Rollout status & diagnostics
          k3s kubectl -n voting rollout status deployment/redis --timeout=180s || true
          k3s kubectl -n voting rollout status deployment/vote --timeout=180s || true
          k3s kubectl -n voting rollout status deployment/result --timeout=180s || true
          k3s kubectl -n voting rollout status deployment/worker --timeout=180s || true
          k3s kubectl -n voting get pods -o wide || true
          k3s kubectl -n voting get svc -o wide || true
          EOS

          # Inject values
          USER_SCRIPT="${USER_SCRIPT//__AWS_REGION__/${AWS_REGION}}"
          USER_SCRIPT="${USER_SCRIPT//__ECR__/${ECR_REGISTRY}}"
          USER_SCRIPT="${USER_SCRIPT//__TAG__/${IMAGE_TAG}}"
          USER_SCRIPT="${USER_SCRIPT//__PUSER__/${POSTGRES_USER}}"
          USER_SCRIPT="${USER_SCRIPT//__PPASS__/${POSTGRES_PASSWORD}}"
          USER_SCRIPT="${USER_SCRIPT//__PDB__/${POSTGRES_DB}}"
          USER_SCRIPT="${USER_SCRIPT//__ECR_PW_B64__/${{ steps.ecrpw.outputs.pw_b64 }}}"

          # Send to SSM
          CMD_ID=$(aws ssm send-command \
            --instance-ids "${EC2_INSTANCE_ID}" \
            --document-name "AWS-RunShellScript" \
            --parameters commands="$(printf '%q' "$USER_SCRIPT")" \
            --query "Command.CommandId" --output text)
          echo "command_id=$CMD_ID" >> "$GITHUB_OUTPUT"
          echo "SSM command sent: $CMD_ID"

      - name: Wait for SSM command to finish
        shell: bash
        run: |
          set -e
          CMD_ID="${{ steps.ssm.outputs.command_id }}"
          echo "Waiting on SSM Command: $CMD_ID"
          for i in {1..40}; do
            STATUS=$(aws ssm list-command-invocations \
              --command-id "$CMD_ID" --details \
              --query 'CommandInvocations[0].Status' --output text || true)
            echo "SSM status: $STATUS"
            if [ "$STATUS" = "Success" ]; then exit 0; fi
            if [[ "$STATUS" = "Cancelled" || "$STATUS" = "TimedOut" || "$STATUS" = "Failed" || "$STATUS" = "Undeliverable" || "$STATUS" = "Incomplete" ]]; then
              echo "SSM command ended with status: $STATUS"
              exit 1
            fi
            sleep 10
          done
          echo "Timed out waiting for SSM command to finish"
          exit 1

      - name: Fetch SSM logs
        if: always()
        shell: bash
        run: |
          set -euo pipefail
          CMD_ID="${{ steps.ssm.outputs.command_id }}"
          INSTANCE="${EC2_INSTANCE_ID}"
          aws ssm get-command-invocation \
            --command-id "$CMD_ID" \
            --instance-id "$INSTANCE" \
            --query '{Status:Status,StandardOutputContent:StandardOutputContent,StandardErrorContent:StandardErrorContent}' \
            --output json || true
