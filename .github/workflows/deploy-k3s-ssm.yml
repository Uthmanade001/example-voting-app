name: Deploy to k3s on EC2 (via SSM)

on:
  workflow_run:
    workflows: ["Build & Push to ECR"]
    types: [completed]
    branches: [main]
  workflow_dispatch:

permissions:
  id-token: write
  contents: read

env:
  AWS_REGION: ${{ secrets.AWS_REGION }}
  ECR_REGISTRY: ${{ secrets.ECR_REGISTRY }}
  EC2_INSTANCE_ID: ${{ secrets.EC2_INSTANCE_ID }}
  POSTGRES_USER: ${{ secrets.POSTGRES_USER }}
  POSTGRES_PASSWORD: ${{ secrets.POSTGRES_PASSWORD }}
  POSTGRES_DB: ${{ secrets.POSTGRES_DB }}

jobs:
  deploy-k3s:
    if: ${{ github.event_name == 'workflow_dispatch' || github.event.workflow_run.conclusion == 'success' }}
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v4

      - uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Resolve IMAGE_TAG (use built commit on auto-trigger)
        run: |
          if [ "${{ github.event_name }}" = "workflow_run" ]; then
            echo "IMAGE_TAG=${{ github.event.workflow_run.head_sha }}" >> $GITHUB_ENV
          else
            echo "IMAGE_TAG=${{ github.sha }}" >> $GITHUB_ENV
          fi
          echo "Using IMAGE_TAG=$IMAGE_TAG"

      - name: Package k8s folder (base64)
        run: |
          tar -C k8s -czf k8s.tgz .
          base64 -w0 k8s.tgz > k8s.b64
          echo "K8S_B64=$(cat k8s.b64)" >> $GITHUB_ENV

      - name: Install k3s + apply manifests via SSM
        id: ssm
        shell: bash
        run: |
          set -euo pipefail
          CMD_ID=$(aws ssm send-command \
            --instance-ids "${EC2_INSTANCE_ID}" \
            --document-name "AWS-RunShellScript" \
            --comment "Deploy to k3s ${IMAGE_TAG}" \
            --parameters commands='[
              "set -euo pipefail",
              "if ! command -v k3s >/dev/null 2>&1; then curl -sfL https://get.k3s.io | sh -; fi",
              "export PATH=/usr/local/bin:$PATH",
              "mkdir -p /opt/k8s",
              "echo '"${K8S_B64}"' | base64 -d > /tmp/k8s.tgz",
              "tar xzf /tmp/k8s.tgz -C /opt/k8s",
              "sed -i '\''s|__ECR__|'"${ECR_REGISTRY}"'|g; s|__TAG__|'"${IMAGE_TAG}"'|g'\'' /opt/k8s/*.yaml",

              # namespace & secrets
              "kubectl apply -f /opt/k8s/namespace.yaml",
              "kubectl -n voting create secret generic db --from-literal=POSTGRES_USER='"${POSTGRES_USER}"' --from-literal=POSTGRES_PASSWORD='"${POSTGRES_PASSWORD}"' --from-literal=POSTGRES_DB='"${POSTGRES_DB}"' --dry-run=client -o yaml | kubectl apply -f -",

              # ECR image pull secret (token valid ~12h)
              "kubectl -n voting create secret docker-registry ecr-creds --docker-server='"${ECR_REGISTRY}"' --docker-username=AWS --docker-password=$(aws ecr get-login-password --region '"${AWS_REGION}"') --dry-run=client -o yaml | kubectl apply -f -",

              # apply app manifests
              "kubectl -n voting apply -f /opt/k8s/postgres.yaml",
              "kubectl -n voting apply -f /opt/k8s/redis.yaml",
              "kubectl -n voting apply -f /opt/k8s/vote.yaml",
              "kubectl -n voting apply -f /opt/k8s/result.yaml",
              "kubectl -n voting apply -f /opt/k8s/worker.yaml",

              # wait for pods
              "kubectl -n voting rollout status deployment/redis --timeout=120s || true",
              "kubectl -n voting rollout status deployment/vote --timeout=180s || true",
              "kubectl -n voting rollout status deployment/result --timeout=180s || true",
              "kubectl -n voting rollout status deployment/worker --timeout=180s || true",
              "kubectl -n voting get pods -o wide"
            ]' \
            --query "Command.CommandId" --output text)
          echo "command_id=$CMD_ID" >> $GITHUB_OUTPUT

      - name: Wait & fetch logs
        run: |
          set -e
          CMD_ID="${{ steps.ssm.outputs.command_id }}"
          for i in {1..40}; do
            STATUS=$(aws ssm list-command-invocations --command-id "$CMD_ID" --details --query 'CommandInvocations[0].Status' --output text || true)
            echo "SSM status: $STATUS"
            [[ "$STATUS" == "Success" ]] && break
            [[ "$STATUS" =~ (Cancelled|TimedOut|Failed|Undeliverable|Incomplete) ]] && break
            sleep 10
          done
          aws ssm get-command-invocation \
            --command-id "$CMD_ID" \
            --instance-id "${{ env.EC2_INSTANCE_ID }}" \
            --query '{Status:Status,StdOut:StandardOutputContent,StdErr:StandardErrorContent}' \
            --output json
