name: Deploy to k3s on EC2 (via SSM)

on:
    workflow_run:
        workflows: ["Build & Push to ECR"]
        types: [completed]
        branches: [main]
    workflow_dispatch:

permissions:
    id-token: write
    contents: read

env:
    AWS_REGION: ${{ secrets.AWS_REGION }}
    ECR_REGISTRY: ${{ secrets.ECR_REGISTRY }}
    EC2_INSTANCE_ID: ${{ secrets.EC2_INSTANCE_ID }}
    POSTGRES_USER: ${{ secrets.POSTGRES_USER }}
    POSTGRES_PASSWORD: ${{ secrets.POSTGRES_PASSWORD }}
    POSTGRES_DB: ${{ secrets.POSTGRES_DB }}

jobs:
    deploy-k3s:
        if: ${{ github.event_name == 'workflow_dispatch' || github.event.workflow_run.conclusion == 'success' }}
        runs-on: ubuntu-latest

        steps:
            - uses: actions/checkout@v4

            - uses: aws-actions/configure-aws-credentials@v4
                with:
                    aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
                    aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
                    aws-region: ${{ env.AWS_REGION }}

            - name: Resolve IMAGE_TAG (use built commit on auto-trigger)
                run: |
                    if [ "${{ github.event_name }}" = "workflow_run" ]; then
                        echo "IMAGE_TAG=${{ github.event.workflow_run.head_sha }}" >> $GITHUB_ENV
                    else
                        echo "IMAGE_TAG=${{ github.sha }}" >> $GITHUB_ENV
                    fi
                    echo "Using IMAGE_TAG=$IMAGE_TAG"

            - name: Package k8s folder (base64)
                run: |
                    tar -C k8s -czf k8s.tgz .
                    base64 -w0 k8s.tgz > k8s.b64
                    echo "K8S_B64=$(cat k8s.b64)" >> $GITHUB_ENV

            - name: Install k3s + apply manifests via SSM
                id: ssm
                shell: bash
                run: |
                    set -euo pipefail
                    # Build one safe script to run on the instance
                    read -r -d '' USER_SCRIPT <<'EOS'
                    set -euo pipefail

                    AWS_REGION="__AWS_REGION__"
                    ECR="__ECR__"
                    TAG="__TAG__"
                    PUSER="__PUSER__"
                    PPASS="__PPASS__"
                    PDB="__PDB__"
                    K8S_B64="__K8S_B64__"

                    # Install k3s if missing
                    if ! command -v k3s >/dev/null 2>&1; then
                        curl -sfL https://get.k3s.io | sh -;
                    fi
                    export PATH=/usr/local/bin:$PATH

                    mkdir -p /opt/k8s
                    echo "$K8S_B64" | base64 -d > /tmp/k8s.tgz
                    tar xzf /tmp/k8s.tgz -C /opt/k8s
                    sed -i "s|__ECR__|$ECR|g; s|__TAG__|$TAG|g" /opt/k8s/*.yaml

                    # Namespace & DB secret
                    kubectl apply -f /opt/k8s/namespace.yaml
                    kubectl -n voting create secret generic db \
                        --from-literal=POSTGRES_USER="$PUSER" \
                        --from-literal=POSTGRES_PASSWORD="$PPASS" \
                        --from-literal=POSTGRES_DB="$PDB" \
                        --dry-run=client -o yaml | kubectl apply -f -

                    # ECR image pull secret
                    kubectl -n voting create secret docker-registry ecr-creds \
                        --docker-server="$ECR" \
                        --docker-username=AWS \
                        --docker-password="$(aws ecr get-login-password --region "$AWS_REGION")" \
                        --dry-run=client -o yaml | kubectl apply -f -

                    # Apply workloads
                    kubectl -n voting apply -f /opt/k8s/postgres.yaml
                    kubectl -n voting apply -f /opt/k8s/redis.yaml
                    kubectl -n voting apply -f /opt/k8s/vote.yaml
                    kubectl -n voting apply -f /opt/k8s/result.yaml
                    kubectl -n voting apply -f /opt/k8s/worker.yaml

                    # Wait and show status
                    kubectl -n voting rollout status deployment/redis --timeout=180s || true
                    kubectl -n voting rollout status deployment/vote --timeout=180s || true
                    kubectl -n voting rollout status deployment/result --timeout=180s || true
                    kubectl -n voting rollout status deployment/worker --timeout=180s || true
                    kubectl -n voting get all -o wide
                    EOS

                    # Inject values
                    USER_SCRIPT="${USER_SCRIPT//__AWS_REGION__/${AWS_REGION}}"
                    USER_SCRIPT="${USER_SCRIPT//__ECR__/${ECR_REGISTRY}}"
                    USER_SCRIPT="${USER_SCRIPT//__TAG__/${IMAGE_TAG}}"
                    USER_SCRIPT="${USER_SCRIPT//__PUSER__/${POSTGRES_USER}}"
                    USER_SCRIPT="${USER_SCRIPT//__PPASS__/${POSTGRES_PASSWORD}}"
                    USER_SCRIPT="${USER_SCRIPT//__PDB__/${POSTGRES_DB}}"
                    USER_SCRIPT="${USER_SCRIPT//__K8S_B64__/${K8S_B64}}"

                    CMD_ID=$(aws ssm send-command \
                        --instance-ids "${EC2_INSTANCE_ID}" \
                        --document-name "AWS-RunShellScript" \
                        --parameters commands="$(printf '%q' "$USER_SCRIPT")" \
                        --query "Command.CommandId" --output text)
                    echo "command_id=$CMD_ID" >> $GITHUB_OUTPUT

            - name: Wait & fetch logs
                run: |
                    set -e
                    CMD_ID="${{ steps.ssm.outputs.command_id }}"
                    for i in {1..40}; do
                        STATUS=$(aws ssm list-command-invocations --command-id "$CMD_ID" --details --query 'CommandInvocations[0].Status' --output text || true)
                        echo "SSM status: $STATUS"
                        [[ "$STATUS" == "Success" ]] && break
                        [[ "$STATUS" =~ (Cancelled|TimedOut|Failed|Undeliverable|Incomplete) ]] && break
                        sleep 10
                    done
                    aws ssm get-command-invocation \
                        --command-id "$CMD_ID" \
                        --instance-id "${{ env.EC2_INSTANCE_ID }}" \
                        --query '{Status:Status,StdOut:StandardOutputContent,StdErr:StandardErrorContent}' \
                        --output json
