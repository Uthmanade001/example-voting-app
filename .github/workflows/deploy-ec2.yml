name: Deploy to EC2 via SSM

on:
  workflow_run:
    workflows: ["Build & Push to ECR"]
    types: [completed]
    branches: [main]
  workflow_dispatch:

env:
  AWS_REGION: ${{ secrets.AWS_REGION }}
  ECR_REGISTRY: ${{ secrets.ECR_REGISTRY }}
  EC2_INSTANCE_ID: ${{ secrets.EC2_INSTANCE_ID }}

jobs:
  deploy:
    if: ${{ github.event_name == 'workflow_dispatch' || github.event.workflow_run.conclusion == 'success' }}
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      # Resolve IMAGE_TAG: when auto-triggered, use the build's head_sha; otherwise use this commit
      - name: Resolve IMAGE_TAG
        id: tag
        run: |
          if [ "${{ github.event_name }}" = "workflow_run" ]; then
            echo "IMAGE_TAG=${{ github.event.workflow_run.head_sha }}" >> $GITHUB_ENV
          else
            echo "IMAGE_TAG=${{ github.sha }}" >> $GITHUB_ENV
          fi
          echo "Using IMAGE_TAG=$IMAGE_TAG"

      - name: Package docker-compose.yml (base64)
        run: |
          base64 -w0 docker-compose.yml > compose.b64
          echo "COMPOSE_B64=$(cat compose.b64)" >> $GITHUB_ENV

      - name: Send SSM Run Command (deploy)
        id: ssm
        shell: bash
        run: |
          set -euo pipefail
          read -r -d '' USER_SCRIPT <<'EOS'
          set -euo pipefail

          sudo yum -y install docker || true
          sudo systemctl enable --now docker
          sudo usermod -aG docker ec2-user || true

          # docker compose v2 shim
          if ! docker compose version >/dev/null 2>&1; then
            sudo curl -L "https://github.com/docker/compose/releases/download/v2.27.1/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
            sudo chmod +x /usr/local/bin/docker-compose
            sudo ln -sf /usr/local/bin/docker-compose /usr/bin/docker-compose
          fi

          sudo mkdir -p /opt/vote
          sudo chown -R ec2-user:ec2-user /opt/vote
          cd /opt/vote

          # Write compose and env values
          echo "$COMPOSE_B64" | base64 -d > docker-compose.yml
          export ECR_REGISTRY="${ECR_REGISTRY}"
          export IMAGE_TAG="${IMAGE_TAG}"

          # ECR login + pull & restart
          aws ecr get-login-password --region ${AWS_REGION} | docker login --username AWS --password-stdin ${ECR_REGISTRY}
          docker compose pull
          docker compose up -d
          docker image prune -f || true

          echo "Deploy complete for tag: ${IMAGE_TAG}"
          EOS

          CMD_ID=$(aws ssm send-command \
            --instance-ids "${EC2_INSTANCE_ID}" \
            --document-name "AWS-RunShellScript" \
            --comment "Deploy via GitHub Actions ${GITHUB_SHA}" \
            --parameters commands="$(printf '%q' "$USER_SCRIPT")" \
            --cloud-watch-output-config CloudWatchOutputEnabled=true \
            --query "Command.CommandId" --output text)

          echo "command_id=$CMD_ID" >> $GITHUB_OUTPUT

          # Wait for completion
          for i in {1..40}; do
            STATUS=$(aws ssm list-command-invocations \
              --command-id "$CMD_ID" --details \
              --query 'CommandInvocations[0].Status' --output text || true)
            echo "SSM status: $STATUS"
            if [ "$STATUS" = "Success" ]; then exit 0; fi
            if [[ "$STATUS" = "Cancelled" || "$STATUS" = "TimedOut" || "$STATUS" = "Failed" ]]; then
              exit 1
            fi
            sleep 10
          done

          echo "Timed out waiting for SSM command to finish" >&2
          exit 1
        env:
          COMPOSE_B64: ${{ env.COMPOSE_B64 }}
          AWS_REGION: ${{ env.AWS_REGION }}
          ECR_REGISTRY: ${{ env.ECR_REGISTRY }}
          EC2_INSTANCE_ID: ${{ env.EC2_INSTANCE_ID }}
          IMAGE_TAG: ${{ env.IMAGE_TAG }}

      # NEW: print SSM stdout/stderr into GitHub logs
      - name: Fetch SSM logs
        if: always()
        run: |
          aws ssm get-command-invocation \
            --command-id "${{ steps.ssm.outputs.command_id }}" \
            --instance-id "${{ env.EC2_INSTANCE_ID }}" \
            --query '{Status:Status,StdOut:StandardOutputContent,StdErr:StandardErrorContent}' \
            --output json
