name: Deploy to EC2 via SSM

on:
  workflow_run:
    workflows: ["Build & Push to ECR"]   # <- must exactly match your build workflow name
    types: [completed]
    branches: [main]
  workflow_dispatch:

permissions:
  id-token: write
  contents: read

env:
  AWS_REGION: ${{ secrets.AWS_REGION }}
  ECR_REGISTRY: ${{ secrets.ECR_REGISTRY }}
  EC2_INSTANCE_ID: ${{ secrets.EC2_INSTANCE_ID }}
  COMPOSE_PATH: infra/compose/dev/docker-compose.yml  # <- your compose location in the repo

jobs:
  deploy:
    if: ${{ github.event_name == 'workflow_dispatch' || github.event.workflow_run.conclusion == 'success' }}
    runs-on: ubuntu-latest
    concurrency:
      group: deploy-ec2
      cancel-in-progress: true

    steps:
      - name: Checkout repo
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Resolve IMAGE_TAG
        id: tag
        shell: bash
        run: |
          if [ "${{ github.event_name }}" = "workflow_run" ]; then
            echo "IMAGE_TAG=${{ github.event.workflow_run.head_sha }}" >> $GITHUB_ENV
          else
            echo "IMAGE_TAG=${{ github.sha }}" >> $GITHUB_ENV
          fi
          echo "Using IMAGE_TAG=$IMAGE_TAG"

      - name: Locate & package docker-compose
        shell: bash
        run: |
          set -e
          echo "Looking for: ${COMPOSE_PATH}"
          if [ ! -f "${COMPOSE_PATH}" ]; then
            echo "ERROR: Could not find ${COMPOSE_PATH}."
            echo "Repo tree (top level):"; ls -la
            exit 1
          fi
          echo "Compose file size: $(wc -c < "${COMPOSE_PATH}") bytes"
          base64 -w0 "${COMPOSE_PATH}" > compose.b64
          echo "Base64 size: $(wc -c < compose.b64) bytes"
          echo "COMPOSE_B64=$(cat compose.b64)" >> $GITHUB_ENV

      - name: Send SSM Run Command (deploy)
        id: ssm
        shell: bash
        run: |
          set -eo pipefail

          # Ensure packaging step succeeded
          if [ -z "${COMPOSE_B64:-}" ]; then
            echo "ERROR: COMPOSE_B64 is empty or unset. Packaging step likely failed."
            exit 1
          fi

          # Build the script that will run on EC2
          read -r -d '' USER_SCRIPT <<'EOS'
          set -euo pipefail

          sudo yum -y install docker || true
          sudo systemctl enable --now docker
          sudo usermod -aG docker ec2-user || true

          # Install docker compose v2 if missing
          if ! docker compose version >/dev/null 2>&1; then
            sudo curl -L "https://github.com/docker/compose/releases/download/v2.27.1/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
            sudo chmod +x /usr/local/bin/docker-compose
            sudo ln -sf /usr/local/bin/docker-compose /usr/bin/docker-compose
          fi

          # Workspace
          sudo mkdir -p /opt/vote
          sudo chown -R ec2-user:ec2-user /opt/vote
          cd /opt/vote

          # Write compose from Base64 (passed by GitHub Actions)
          echo "__COMPOSE_B64__" | base64 -d > docker-compose.yml

          # Env for compose
          export ECR_REGISTRY="__ECR_REGISTRY__"
          export IMAGE_TAG="__IMAGE_TAG__"
          export AWS_REGION="__AWS_REGION__"

          # ECR login + pull & restart
          aws ecr get-login-password --region "$AWS_REGION" | docker login --username AWS --password-stdin "$ECR_REGISTRY"
          docker compose pull
          docker compose up -d
          docker image prune -f || true

          echo "Deploy complete for tag: $IMAGE_TAG"
          EOS

          # Inject values safely
          USER_SCRIPT="${USER_SCRIPT//__COMPOSE_B64__/${COMPOSE_B64}}"
          USER_SCRIPT="${USER_SCRIPT//__ECR_REGISTRY__/${ECR_REGISTRY}}"
          USER_SCRIPT="${USER_SCRIPT//__IMAGE_TAG__/${IMAGE_TAG}}"
          USER_SCRIPT="${USER_SCRIPT//__AWS_REGION__/${AWS_REGION}}"

          # Send the command to the instance
          CMD_ID=$(aws ssm send-command \
            --instance-ids "${EC2_INSTANCE_ID}" \
            --document-name "AWS-RunShellScript" \
            --comment "Deploy via GitHub Actions ${GITHUB_SHA}" \
            --parameters commands="$(printf '%q' "$USER_SCRIPT")" \
            --cloud-watch-output-config CloudWatchOutputEnabled=true \
            --query "Command.CommandId" --output text)

          echo "command_id=$CMD_ID" >> $GITHUB_OUTPUT

      - name: Wait for SSM command to finish
        shell: bash
        run: |
          set -e
          CMD_ID="${{ steps.ssm.outputs.command_id }}"
          echo "Waiting on SSM Command: $CMD_ID"
          for i in {1..40}; do
            STATUS=$(aws ssm list-command-invocations \
              --command-id "$CMD_ID" --details \
              --query 'CommandInvocations[0].Status' --output text || true)
            echo "SSM status: $STATUS"
            if [ "$STATUS" = "Success" ]; then exit 0; fi
            if [[ "$STATUS" = "Cancelled" || "$STATUS" = "TimedOut" || "$STATUS" = "Failed" || "$STATUS" = "Undeliverable" || "$STATUS" = "Incomplete" ]]; then
              echo "SSM command ended with status: $STATUS"
              exit 1
            fi
            sleep 10
          done
          echo "Timed out waiting for SSM command to finish"
          exit 1

      - name: Fetch SSM logs
        if: ${{ steps.ssm.outputs.command_id != '' }}
        shell: bash
        run: |
          aws ssm get-command-invocation \
            --command-id "${{ steps.ssm.outputs.command_id }}" \
            --instance-id "${{ env.EC2_INSTANCE_ID }}" \
            --query '{Status:Status,StdOut:StandardOutputContent,StdErr:StandardErrorContent}' \
            --output json

      - name: Show SSM command link (console)
        if: ${{ steps.ssm.outputs.command_id != '' }}
        run: |
          echo "Open in console:"
          echo "https://${{ env.AWS_REGION }}.console.aws.amazon.com/systems-manager/run-command/${{ steps.ssm.outputs.command_id }}?region=${{ env.AWS_REGION }}"
